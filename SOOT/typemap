SOOT*	O_OBJECT
ClassIterator*	O_OBJECT
std::vector< double >*	T_VECTORDOUBLE
std::vector< Vec >*		T_VECTORVEC
std::istream*		T_ISTREAM
const double		T_NV
TArrayD* O_TOBJECT
TArrayS* O_TOBJECT
TArrayI* O_TOBJECT
TArrayF* O_TOBJECT
TArrayL* O_TOBJECT
TArrayC* O_TOBJECT

INPUT

T_ISTREAM
	$var = new std::istringstream(SvPV_nolen($arg));

O_TOBJECT
	$var =($type)SOOT::LobotomizeObject(aTHX_ $arg);

T_VECTORVEC
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = new std::vector<Vec>(len);
	  for (unsigned int i = 0; i < len; ++i) {
	    SV** elem;
	    AV* vecAv;
	    elem = av_fetch(av, i, 0);
	    if (elem == NULL || !SvROK(*elem) || SvTYPE(SvRV(*elem))!=SVt_PVAV)
	      Perl_croak(aTHX_ \"%s: Element %u in argument %s is not an array reference\",
	                 ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	                 i, \"$var\");
	    vecAv = (AV*)SvRV(*elem);
	    const unsigned int vecLen = av_len(vecAv)+1;
	    if (vecLen != 3)
	      Perl_croak(aTHX_ \"%s: Element %u in argument %s is not an array of three components (x/y/z)\",
	                 ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	                 i, \"$var\");
	    elem = av_fetch(vecAv, 0, 0);
	    if (elem != NULL)
	      (*$var)[i].x = SvNV(*elem);
	    else
	      (*$var)[i].x = 0.;
	    elem = av_fetch(vecAv, 1, 0);
	    if (elem != NULL)
	      (*$var)[i].y = SvNV(*elem);
	    else
	      (*$var)[i].y = 0.;
	    elem = av_fetch(vecAv, 2, 0);
	    if (elem != NULL)
	      (*$var)[i].z = SvNV(*elem);
	    else
	      (*$var)[i].z = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");

T_VECTORDOUBLE
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {                                                                              
	  AV* av = (AV*)SvRV($arg);                                                                                                  
	  const unsigned int len = av_len(av)+1;                                                                                      
	  $var = new std::vector<double>(len);                                                                                        
	  for (unsigned int i = 0; i < len; i++) {                                                                                    
	    SV** elem;                                                                                                              
	    elem = av_fetch(av, i, 0);                                                                                              
	    if (elem != NULL)
	      (*$var)[i] = SvNV(*elem);
	    else
	      (*$var)[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");

OUTPUT

O_TOBJECT
	$arg = SOOT::RegisterObject(aTHX_ (TObject*)$var, "${my $t=$type; $t=~s/^\s*const\b\s*//;$t=~s/\s*[*&]*\s*$//;\$t}");

T_VECTORVEC
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size();
	av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  AV* vecAv = newAV();
	  const Vec& v = (*$var)[i];
	  av_extend(vecAv, 2);
	  av_store(vecAv, 0, newSVnv(v.x));
	  av_store(vecAv, 1, newSVnv(v.y));
	  av_store(vecAv, 2, newSVnv(v.z));
	  av_store(av, i, newRV_noinc((SV*)vecAv));
	}

T_VECTORDOUBLE
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size();
	av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  av_store(av, i, newSVnv((*$var)[i]));
	}

